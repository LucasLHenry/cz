from enum import Enum, auto
from typing import Literal
import numpy as np
import os

TABLE_NUM_BITS = 12
TABLE_LEN = 2 ** TABLE_NUM_BITS
SAMPLE_FREQ = 48000
PATH_TO_TABLES = "/tables/"
FILE_NAME = "waves.h"
RESO_WAVE_HARMONICS = [32, 16, 8, 4, 3]
RESO_WAVE_TYPE = "tri"


file_header = """// autogenerated by scripts/generate_waves.py
// do not modify!!
#include<stdint.h>
#ifndef TABLES_WAVES_H_
#define TABLES_WAVES_H_
"""

array_footer = "};\n"
file_footer = "#endif  // TABLES_WAVES_H_"

def main():
    saw = generate_saw()
    sine = generate_sine()
    tri = generate_tri()

    downshift = 32 - TABLE_NUM_BITS
    hz_phasor = int(2**32 / SAMPLE_FREQ)
    
    file_path = f"{os.getcwd()}{PATH_TO_TABLES}{FILE_NAME}"
    # output_type = OutputType.INT16
    with open(file_path, 'w') as f:
        f.write(file_header)
        f.write(f"const uint32_t k_wave_table_len = {TABLE_LEN};\n")
        f.write(f"const uint32_t k_dds_downshift = {downshift};\n")
        f.write(f"const uint32_t k_hz_phasor = {hz_phasor};\n")
        write_table(f, "sine_table", sine)
        write_table(f, "saw_table", saw)
        write_table(f, "tri_table", tri)
        write_reso_tables(f, sine)
        f.write(file_footer)
        
   
def write_reso_tables(f, sine_table):
    total_table = []
    for harmonic in RESO_WAVE_HARMONICS:
        table = generate_reso_ramp(harmonic) if RESO_WAVE_TYPE == "ramp" else generate_reso_tri(harmonic)
        total_table.append(table)
    total_table.append(sine_table)
    write_2d_table(f, "reso_waves", total_table)
    f.write(f"#define NUM_RESO_WAVES {len(RESO_WAVE_HARMONICS) + 1}\n")
    # f.write(f"const int16_t* reso_tables[{len(RESO_WAVE_HARMONICS) + 1}] = {{\n")
    # for harmonic in RESO_WAVE_HARMONICS:
    #     f.write(f"\treso_{RESO_WAVE_TYPE}_table_{harmonic},\n")
    # f.write(f"\tsine_table,\n")
    # f.write("};\n")
        
def write_2d_table(f, table_name: str, table: list[list[float]]):
    f.write(f"const int16_t {table_name}[][{TABLE_LEN}] = {{\n")
    for sublist in table:
        f.write("{")
        for i in range(TABLE_LEN):
            val = int(sublist[i] * (2**15 - 1))
            arr_write_item(f, i , val, 32, TABLE_LEN)
        f.write("},")
    f.write("};\n")
    
def write_table(f, table_name: str, table: list[float]):
    f.write(f"const int16_t {table_name}[{TABLE_LEN}] = {{\n")
    for i in range(TABLE_LEN):
        val = int(table[i] * (2**15 - 1))
        arr_write_item(f, i, val, 32, TABLE_LEN)
    f.write(array_footer)
    
def arr_write_item(f, idx, val_to_write, vals_per_line, arr_len):
    if isinstance(val_to_write, float):
        val_to_write = f"{val_to_write:E}"
    if idx != arr_len-1:
        f.write(f"{val_to_write}, ")
    else:
        f.write(f"{val_to_write}")
    
    if (idx + 1) % vals_per_line == 0:
        f.write("\n")
    
def generate_saw() -> list[float]:
    arr = []
    for i in range(TABLE_LEN):
        val = 2 * i / TABLE_LEN
        if i < TABLE_LEN/2:
            arr.append(val)
        else:
            arr.append(val - 2)
    return arr

def generate_sine() -> list[float]:
    arr = []
    for i in range(TABLE_LEN):
        val = np.cos(2*np.pi*i/TABLE_LEN)
        arr.append(val)
    return arr

def generate_tri() -> list[float]:
    arr = []
    for i in range(TABLE_LEN):
        val = 4 * i / TABLE_LEN
        if i < TABLE_LEN/4:
            arr.append(val)
        elif i >= TABLE_LEN/4 and i < 3*TABLE_LEN/4:
            arr.append(2-val)
        else:
            arr.append(val-4)
    return arr

def generate_reso_ramp(freq_mult: int) -> list[float]:
    arr = []
    for i in range(TABLE_LEN):
        val = (-np.cos(2*freq_mult*np.pi*i/TABLE_LEN) + 1) / 2
        val *= i/TABLE_LEN
        val -= 0.5
        val *= 2
        arr.append(val)
    return arr

def generate_reso_tri(freq_mult: int) -> list[float]:
    arr = []
    for i in range(TABLE_LEN):
        val = (-np.cos(2*freq_mult*np.pi*i/TABLE_LEN) + 1) / 2
        if i < TABLE_LEN/2:
            val *= i*2/TABLE_LEN
        else:
            val *= (TABLE_LEN - i)*2/TABLE_LEN
        val -= 0.5
        val *= 2
        arr.append(val)
    return arr

if __name__ == "__main__":
    main()